apply plugin: 'com.tencent.bugly.tinker-support'

apply from: "${rootDir}/script/config.gradle"
apply from: "${rootDir}/script/tool.gradle"
apply from: "${rootDir}/script/andresguard-support.gradle"

android {
    defaultConfig {
        buildConfigField "String", "BUGLY_APP_ID", "\"${rootProject.ext.buglyAppId}\""
        buildConfigField "Boolean", "ENABLE_HOTFIX", "${rootProject.ext.enableHotfix}"
        buildConfigField "Boolean", "CAN_AUTODOWNLOAD_PATCH", "${rootProject.ext.canAutoDownloadPatch}"
        buildConfigField "Boolean", "CAN_AUTOPATCH", "${rootProject.ext.canAutoPatch}"
        buildConfigField "Boolean", "CAN_NOTIFY_USER_RESTART", "${rootProject.ext.canNotifyUserRestart}"
        buildConfigField "String", "TINKER_ID", "\"${rootProject.ext.tinkerId}\""
    }
}

def fillBaseApkPath() {
    String baseDir = rootProject.ext.baseDir
    if (baseDir.isEmpty()) {
        println "baseDir not found error, return."
        return
    }
    if (!file(baseDir).exists()) {
        println "baseDir not found error, return."
        rootProject.ext.baseDir = ''
        return
    }
    rootProject.ext.baseApkProguardMappingPath = "${rootProject.ext.baseDir}/mapping.txt"
    def outDirResGuard = file(rootProject.ext.baseDir)
    println "fillBaseApkPath ===> ${outDirResGuard} ${outDirResGuard.isDirectory()}"
    if (outDirResGuard.isDirectory()) {
        outDirResGuard.eachFileRecurse { file ->
            if (file.name.endsWith(".apk")) {
                rootProject.ext.baseApkPath = "${outDirResGuard}/${file.name}"
            }
            if (file.name.endsWith("R.txt")) {
                rootProject.ext.baseApkResourceMappingPath = "${outDirResGuard}/${file.name}"
            }
        }
    }
    println "baseApkPath ===> ${rootProject.ext.baseApkPath}"
    println "baseApkProguardMappingPath ===> ${rootProject.ext.baseApkProguardMappingPath}"
    println "baseApkResourceMappingPath ===> ${rootProject.ext.baseApkResourceMappingPath}"
}

def fillNewApkPath() {
    String newApk = rootProject.ext.newApk
    if (newApk.isEmpty()) {
        println "newApk not found error, return."
        return
    }
    def newApkFile = file(newApk)
    if (!newApkFile.exists()) {
        println "newApk not found error, return."
        rootProject.ext.newApk = ''
        return
    }
    if (newApkFile.isDirectory()) {
        def newApkPath = newApkFile.absolutePath + "/${newApkFile.name}-resguard.apk"
        rootProject.ext.newApk = newApkPath
        println "newApkPath ==>> ${rootProject.ext.newApk}"
    }
    if (newApk.endsWith(".apk")) {
        println "newApkPath ==>> ${rootProject.ext.newApk}"
    } else {
        println "newApk not found error ==>> ${rootProject.ext.newApk}"
    }
}

/**
 * 对于插件各参数的详细解析请参考，如果没有特殊需求下面的参数都可以不用更改；如果apk需要加固等可以参考具体描述设置参数
 */
tinkerSupport {

    // 开启tinker-support插件，默认值true
    enable = rootProject.ext.enableHotfix
    // 指定归档目录，默认值当前module的子目录tinker
    autoBackupApkDir = "${rootProject.ext.autoBakPath}"
    //建议设置true,用户就不用再自己管理tinkerId的命名,插件会为每一次构建的base包自动生成唯一的tinkerId，默认命名规则是versionname.versioncode_时间戳
    //具体参考https://github.com/BuglyDevTeam/Bugly-Android-Demo/wiki/Tinker-ID%E8%AF%A5%E6%80%8E%E4%B9%88%E8%AE%BE%E7%BD%AE
    autoGenerateTinkerId = false
    //tinkerId必须保证唯一性，如果两个base包的tinkerid是一样的，并且都联网激活了，那么后续补丁上传到后台的时候会出现匹配错误
    tinkerId = rootProject.ext.tinkerId

    //不希望被更新的类
    dexLoader += ["com.tencent.bugly.hotfix.info.BaseBuildInfo"]

    // 是否启用覆盖tinkerPatch配置功能，默认值false
    // 开启后tinkerPatch配置不生效，即无需添加tinkerPatch
    overrideTinkerPatchConfiguration = true

    // 文件匹配
    fillBaseApkPath()
    fillNewApkPath()

    // 编译补丁包时，必需指定基线版本的apk，默认值为空
    // 如果为空，则表示不是进行补丁包的编译
    // @{link tinkerPatch.oldApk }
    baseApk = "${rootProject.ext.baseApkPath}"
    // 对应tinker插件applyResourceMapping
    baseApkResourceMapping = "${rootProject.ext.baseApkResourceMappingPath}"
    // 对应tinker插件applyMapping
    baseApkProguardMapping = "${rootProject.ext.baseApkProguardMappingPath}"

    // buildAllFlavorsDir = "${bakPath}/${baseApkDir}"
    // 是否开启加固模式，默认为false
    isProtectedApp = rootProject.ext.isProtectedApp

    //是否使用自动代理的方式接入（改动小 目前使用该方式）
    enableProxyApplication = true

    //是否支持新增非export的Activity
    supportHotplugComponent = true

    //是否忽略部分警告 （false则会导致补丁生成失效）
    ignoreWarning = true
}

/**
 * 一般来说,我们无需对下面的参数做任何的修改
 * 对于各参数的详细介绍请参考:
 * https://github.com/Tencent/tinker/wiki/Tinker-%E6%8E%A5%E5%85%A5%E6%8C%87%E5%8D%97
 * 或者bugly：
 * https://bugly.qq.com/docs/utility-tools/plugin-gradle-hotfix/?v=20200622202242
 */
tinkerPatch {
    //oldApk ="${bakPath}/${appName}/app-debug.apk"
    useSign = true
    dex {
        dexMode = "jar"
        pattern = ["classes*.dex"]
        loader = []
    }
    lib {
        pattern = ["lib/*/*.so"]
    }

    res {
        pattern = ["res/*", "r/*", "assets/*", "resources.arsc", "AndroidManifest.xml"]
        ignoreChange = []
        largeModSize = 100
    }

    packageConfig {
    }
    sevenZip {
        zipArtifact = "com.tencent.mm:SevenZip:${rootProject.ext.lib7zip}"

//        path = "/usr/local/bin/7za"
    }

    buildConfig {
        keepDexApply = false
        //tinkerId = "1.0.1-patch"
        //applyMapping = "${bakPath}/${appName}/app-debug-mapping.txt" //  可选，设置mapping文件，建议保持旧apk的proguard混淆方式
        //applyResourceMapping = "${bakPath}/${appName}/app-debug-R.txt" // 可选，设置R.txt文件，通过旧apk文件保持ResId的分配
    }
}

apply from: "${rootDir}/script/andres-tinker-support.gradle"